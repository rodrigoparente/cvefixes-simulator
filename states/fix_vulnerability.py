# third-party imports
import pandas as pd

# local imports
from .constants import FIX_VULNERABILITY
from .constants import ERROR_STATE
from .constants import END_STATE


def get_stats_values(df):
    return {
        'cvss_score': df['base_score'].sum() / df.shape[0],
        'exploit': df.loc[~df['exploit_count'].isnull(), 'exploit_count'].shape[0],
        'epss': df['epss'].sum() / df.shape[0],
        'environment': df.loc[df['environment'] == 'PRODUCTION'].shape[0],
        'asset_type': df.loc[df['asset_type'] == 'SERVER'].shape[0],
        'critical_asset': df.loc[df['critical_asset'] == 1].shape[0]
    }


def fix_vulnerability(env):

    curr_rep = env['curr_rep']
    vulns_to_fix = env['fix_vulns_per_rep']

    if curr_rep == env['rep'] + 1:
        del env['curr_rep']
        return (END_STATE, env)

    cvss_order = env['iterations'][curr_rep]['cvss_order']
    frape_order = env['iterations'][curr_rep]['frape_order']

    if len(cvss_order) < vulns_to_fix:
        env = {**env, 'errors': ['Not enough vulnerabilities to fix.']}
        return (ERROR_STATE, env)

    cvss_order = cvss_order[vulns_to_fix:]
    frape_order = frape_order[vulns_to_fix:]

    df = pd.DataFrame.from_records(env['vulnerabilities'])

    cvss_df = df.loc[df['cve_id'].isin(cvss_order)]
    frape_df = df.loc[df['cve_id'].isin(frape_order)]

    env['curr_rep'] += 1

    env['iterations'].setdefault(env['curr_rep'], {
        'cvss_order': cvss_order,
        'frape_order': frape_order,
        'stats_cvss': get_stats_values(cvss_df),
        'stats_frape': get_stats_values(frape_df),
    })

    return (FIX_VULNERABILITY, env)
