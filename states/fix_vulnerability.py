# third-party imports
import pandas as pd

# project imports
from commons.stats import get_stats

# local imports
from .constants import GENERATE_NETWORK
from .constants import ERROR_STATE
from .constants import END_STATE


def fix_vulnerability(env):

    current_rep = env['current_rep']
    vulns_to_fix = env['fix_vulns_per_rep']

    if current_rep > env['rep']:
        del env['current_rep']
        return (END_STATE, env)

    cvss_sorted = env['iterations']['cvss_sorted']
    frape_sorted = env['iterations']['frape_sorted']

    if len(cvss_sorted) < vulns_to_fix or len(frape_sorted) < vulns_to_fix:
        env = {**env, 'errors': ['Not enough vulnerabilities to fix.']}
        return (ERROR_STATE, env)

    cvss_sorted = cvss_sorted[vulns_to_fix:]
    frape_sorted = frape_sorted[vulns_to_fix:]

    cvss_vulns = pd.DataFrame.from_records(env['cvss_vulnerabilities'])
    frape_vulns = pd.DataFrame.from_records(env['frape_vulnerabilities'])

    # removing fixed vulnerabilities from the pool
    cvss_remaining_vulns = cvss_vulns.loc[cvss_vulns['cve_id'].isin(cvss_sorted)]
    frape_remaining_vulns = frape_vulns.loc[frape_vulns['cve_id'].isin(frape_sorted)]

    # updating vulnerabilities list
    cvss_vulnerabilities = cvss_remaining_vulns.to_dict(orient='records')
    frape_vulnerabilities = frape_remaining_vulns.to_dict(orient='records')

    cvss_stats = env['iterations']['cvss_stats']
    frape_stats = env['iterations']['frape_stats']

    env = {
        **env,
        'current_rep': env['current_rep'] + 1,
        'cvss_vulnerabilities': cvss_vulnerabilities,
        'frape_vulnerabilities': frape_vulnerabilities,
        'iterations': {
            'cvss_sorted': cvss_sorted,
            'frape_sorted': frape_sorted,
            'cvss_stats': [*cvss_stats, get_stats(cvss_remaining_vulns)],
            'frape_stats': [*frape_stats, get_stats(frape_remaining_vulns)]
        }
    }

    return (GENERATE_NETWORK, env)
