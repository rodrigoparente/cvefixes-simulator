# third-party imports
import pandas as pd
import numpy as np

# project imports
from commons.file import load_model
from commons.data import encode_data

# local imports
from .constants import PRIORITIZE_VULNERABILITY
from .constants import ERROR_STATE


def classify_vulnerability(env):

    # not the first iteration and
    # there is no new vulnerabilities
    if env['current_rep'] > 1 and \
            env['new_vulns_per_rep'] == 0:
        return (PRIORITIZE_VULNERABILITY, env)

    learner = load_model(env['model']['learner'])

    if not learner:
        env = {**env, 'errors': ['Learner not found.']}
        return (ERROR_STATE, env)

    errors = list()

    frape_vulnerabilities = env['frape_vulnerabilities']
    risk_labels = ['LOW', 'MODERATE', 'IMPORTANT', 'CRITICAL']

    for vuln in frape_vulnerabilities:

        # check if vulnerability was already
        # classified or the model was retrained
        if vuln.keys() >= {'risk_score', 'risk_proba'} and \
                not env['model_config']['retrain_model']:
            continue

        df = pd.DataFrame.from_records([vuln])
        df.drop(columns=['cve_id', 'base_severity', 'asset_id'], inplace=True)

        df = encode_data(df)
        df = df.to_numpy()

        try:
            predicted = np.squeeze(learner.predict_proba(df))
            class_index = np.argmax(predicted)

            vuln['risk_score'] = risk_labels[class_index]
            vuln['risk_proba'] = predicted[class_index]
        except ValueError:
            errors.append(f"Could not predict risk for vuln {vuln['cve_id']}")
            continue

    if len(errors) > 0:
        env = {**env, 'errors': errors}
        return (ERROR_STATE, env)

    env = {
        **env,
        'frape_vulnerabilities': frape_vulnerabilities
    }

    return (PRIORITIZE_VULNERABILITY, env)
